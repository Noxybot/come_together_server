// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: come_together.proto
#ifndef GRPC_come_5ftogether_2eproto__INCLUDED
#define GRPC_come_5ftogether_2eproto__INCLUDED

#include "come_together.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace come_together_grpc {

class MainEndpoint final {
 public:
  static constexpr char const* service_full_name() {
    return "come_together_grpc.MainEndpoint";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::come_together_grpc::ask_token_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>> AsyncAskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>>(AsyncAskTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>> PrepareAsyncAskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>>(PrepareAsyncAskTokenRaw(context, request, cq));
    }
    virtual ::grpc::Status VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::come_together_grpc::verify_token_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>> AsyncVerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>>(AsyncVerifyTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>> PrepareAsyncVerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>>(PrepareAsyncVerifyTokenRaw(context, request, cq));
    }
    // **********************************************************//
    virtual ::grpc::Status Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::come_together_grpc::check_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>> AsyncCheck(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::come_together_grpc::register_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>> AsyncRegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>>(AsyncRegisterUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>> PrepareAsyncRegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>>(PrepareAsyncRegisterUserRaw(context, request, cq));
    }
    virtual ::grpc::Status LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::come_together_grpc::login_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>> AsyncLoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>>(AsyncLoginUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>> PrepareAsyncLoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>>(PrepareAsyncLoginUserRaw(context, request, cq));
    }
    // **********************************************************//
    virtual ::grpc::Status AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::come_together_grpc::add_marker_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>> AsyncAddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>>(AsyncAddMarkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>> PrepareAsyncAddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>>(PrepareAsyncAddMarkerRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::come_together_grpc::delete_marker_reponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>> AsyncDeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>>(AsyncDeleteMarkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>> PrepareAsyncDeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>>(PrepareAsyncDeleteMarkerRaw(context, request, cq));
    }
    // may be unused (for now)
    std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::marker_info>> GetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::marker_info>>(GetAllMarkersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>> AsyncGetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>>(AsyncGetAllMarkersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>> PrepareAsyncGetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>>(PrepareAsyncGetAllMarkersRaw(context, request, cq));
    }
    // **********************************************************//
    // may be unused (for now)
    virtual ::grpc::Status GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::come_together_grpc::get_info_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>> AsyncGetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>>(AsyncGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>> PrepareAsyncGetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>>(PrepareAsyncGetInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::come_together_grpc::update_info_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>> AsyncUpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>>(AsyncUpdateInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>> PrepareAsyncUpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>>(PrepareAsyncUpdateInfoRaw(context, request, cq));
    }
    // **********************************************************//
    virtual ::grpc::Status ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::come_together_grpc::manage_image_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>> AsyncManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>>(AsyncManageImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>> PrepareAsyncManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>>(PrepareAsyncManageImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::image>> GetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::image>>(GetImagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>> AsyncGetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>>(AsyncGetImagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>> PrepareAsyncGetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>>(PrepareAsyncGetImagesRaw(context, request, cq));
    }
    // **********************************************************//
    virtual ::grpc::Status SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::come_together_grpc::send_chat_message_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>> AsyncSendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>>(AsyncSendChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>> PrepareAsyncSendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>>(PrepareAsyncSendChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::chat_message>> GetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::chat_message>>(GetChatMessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>> AsyncGetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>>(AsyncGetChatMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>> PrepareAsyncGetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>>(PrepareAsyncGetChatMessagesRaw(context, request, cq));
    }
    //
    // Events:
    // Add new marker to map or message to chat
    // Edit existing marker, message or user profile
    // Delete existing marker or image
    std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::event>> SubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::come_together_grpc::event>>(SubscribeToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>> AsyncSubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>>(AsyncSubscribeToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>> PrepareAsyncSubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>>(PrepareAsyncSubscribeToEventsRaw(context, request, cq));
    }
    virtual ::grpc::Status SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::come_together_grpc::send_push_token_response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>> AsyncSendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>>(AsyncSendPushTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>> PrepareAsyncSendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>>(PrepareAsyncSendPushTokenRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // **********************************************************//
      virtual void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // **********************************************************//
      virtual void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // may be unused (for now)
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAllMarkers(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::ClientReadReactor< ::come_together_grpc::marker_info>* reactor) = 0;
      #else
      virtual void GetAllMarkers(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::marker_info>* reactor) = 0;
      #endif
      // **********************************************************//
      // may be unused (for now)
      virtual void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // **********************************************************//
      virtual void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetImages(::grpc::ClientContext* context, ::come_together_grpc::get_images_request* request, ::grpc::ClientReadReactor< ::come_together_grpc::image>* reactor) = 0;
      #else
      virtual void GetImages(::grpc::ClientContext* context, ::come_together_grpc::get_images_request* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::image>* reactor) = 0;
      #endif
      // **********************************************************//
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetChatMessages(::grpc::ClientContext* context, ::come_together_grpc::get_chat_messages_request* request, ::grpc::ClientReadReactor< ::come_together_grpc::chat_message>* reactor) = 0;
      #else
      virtual void GetChatMessages(::grpc::ClientContext* context, ::come_together_grpc::get_chat_messages_request* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::chat_message>* reactor) = 0;
      #endif
      //
      // Events:
      // Add new marker to map or message to chat
      // Edit existing marker, message or user profile
      // Delete existing marker or image
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeToEvents(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::ClientReadReactor< ::come_together_grpc::event>* reactor) = 0;
      #else
      virtual void SubscribeToEvents(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::event>* reactor) = 0;
      #endif
      virtual void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>* AsyncAskTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::ask_token_response>* PrepareAsyncAskTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>* AsyncVerifyTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::verify_token_response>* PrepareAsyncVerifyTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>* AsyncCheckRaw(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::check_response>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>* AsyncRegisterUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::register_response>* PrepareAsyncRegisterUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>* AsyncLoginUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::login_response>* PrepareAsyncLoginUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>* AsyncAddMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::add_marker_response>* PrepareAsyncAddMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>* AsyncDeleteMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::delete_marker_reponse>* PrepareAsyncDeleteMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::come_together_grpc::marker_info>* GetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>* AsyncGetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::marker_info>* PrepareAsyncGetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>* AsyncGetInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::get_info_response>* PrepareAsyncGetInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>* AsyncUpdateInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::update_info_response>* PrepareAsyncUpdateInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>* AsyncManageImageRaw(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::manage_image_response>* PrepareAsyncManageImageRaw(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::come_together_grpc::image>* GetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>* AsyncGetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::image>* PrepareAsyncGetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>* AsyncSendChatMessageRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_chat_message_response>* PrepareAsyncSendChatMessageRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::come_together_grpc::chat_message>* GetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>* AsyncGetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::chat_message>* PrepareAsyncGetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::come_together_grpc::event>* SubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>* AsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::come_together_grpc::event>* PrepareAsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>* AsyncSendPushTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::come_together_grpc::send_push_token_response>* PrepareAsyncSendPushTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::come_together_grpc::ask_token_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>> AsyncAskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>>(AsyncAskTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>> PrepareAsyncAskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>>(PrepareAsyncAskTokenRaw(context, request, cq));
    }
    ::grpc::Status VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::come_together_grpc::verify_token_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>> AsyncVerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>>(AsyncVerifyTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>> PrepareAsyncVerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>>(PrepareAsyncVerifyTokenRaw(context, request, cq));
    }
    ::grpc::Status Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::come_together_grpc::check_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>> AsyncCheck(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>>(AsyncCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>> PrepareAsyncCheck(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>>(PrepareAsyncCheckRaw(context, request, cq));
    }
    ::grpc::Status RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::come_together_grpc::register_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>> AsyncRegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>>(AsyncRegisterUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>> PrepareAsyncRegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>>(PrepareAsyncRegisterUserRaw(context, request, cq));
    }
    ::grpc::Status LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::come_together_grpc::login_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>> AsyncLoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>>(AsyncLoginUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>> PrepareAsyncLoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>>(PrepareAsyncLoginUserRaw(context, request, cq));
    }
    ::grpc::Status AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::come_together_grpc::add_marker_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>> AsyncAddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>>(AsyncAddMarkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>> PrepareAsyncAddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>>(PrepareAsyncAddMarkerRaw(context, request, cq));
    }
    ::grpc::Status DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::come_together_grpc::delete_marker_reponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>> AsyncDeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>>(AsyncDeleteMarkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>> PrepareAsyncDeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>>(PrepareAsyncDeleteMarkerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::marker_info>> GetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::marker_info>>(GetAllMarkersRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>> AsyncGetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>>(AsyncGetAllMarkersRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>> PrepareAsyncGetAllMarkers(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>>(PrepareAsyncGetAllMarkersRaw(context, request, cq));
    }
    ::grpc::Status GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::come_together_grpc::get_info_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>> AsyncGetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>>(AsyncGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>> PrepareAsyncGetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>>(PrepareAsyncGetInfoRaw(context, request, cq));
    }
    ::grpc::Status UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::come_together_grpc::update_info_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>> AsyncUpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>>(AsyncUpdateInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>> PrepareAsyncUpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>>(PrepareAsyncUpdateInfoRaw(context, request, cq));
    }
    ::grpc::Status ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::come_together_grpc::manage_image_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>> AsyncManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>>(AsyncManageImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>> PrepareAsyncManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>>(PrepareAsyncManageImageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::image>> GetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::image>>(GetImagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::image>> AsyncGetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::image>>(AsyncGetImagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::image>> PrepareAsyncGetImages(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::image>>(PrepareAsyncGetImagesRaw(context, request, cq));
    }
    ::grpc::Status SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::come_together_grpc::send_chat_message_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>> AsyncSendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>>(AsyncSendChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>> PrepareAsyncSendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>>(PrepareAsyncSendChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::chat_message>> GetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::chat_message>>(GetChatMessagesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>> AsyncGetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>>(AsyncGetChatMessagesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>> PrepareAsyncGetChatMessages(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>>(PrepareAsyncGetChatMessagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::event>> SubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::come_together_grpc::event>>(SubscribeToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::event>> AsyncSubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::event>>(AsyncSubscribeToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::event>> PrepareAsyncSubscribeToEvents(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::come_together_grpc::event>>(PrepareAsyncSubscribeToEventsRaw(context, request, cq));
    }
    ::grpc::Status SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::come_together_grpc::send_push_token_response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>> AsyncSendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>>(AsyncSendPushTokenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>> PrepareAsyncSendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>>(PrepareAsyncSendPushTokenRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, std::function<void(::grpc::Status)>) override;
      void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AskToken(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AskToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::ask_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, std::function<void(::grpc::Status)>) override;
      void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyToken(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void VerifyToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::verify_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, std::function<void(::grpc::Status)>) override;
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Check(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::check_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, std::function<void(::grpc::Status)>) override;
      void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RegisterUser(::grpc::ClientContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RegisterUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::register_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, std::function<void(::grpc::Status)>) override;
      void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LoginUser(::grpc::ClientContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LoginUser(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::login_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, std::function<void(::grpc::Status)>) override;
      void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddMarker(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::add_marker_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteMarker(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteMarker(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::delete_marker_reponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAllMarkers(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::ClientReadReactor< ::come_together_grpc::marker_info>* reactor) override;
      #else
      void GetAllMarkers(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::marker_info>* reactor) override;
      #endif
      void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, std::function<void(::grpc::Status)>) override;
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInfo(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::get_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, std::function<void(::grpc::Status)>) override;
      void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateInfo(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateInfo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::update_info_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, std::function<void(::grpc::Status)>) override;
      void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ManageImage(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ManageImage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::manage_image_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetImages(::grpc::ClientContext* context, ::come_together_grpc::get_images_request* request, ::grpc::ClientReadReactor< ::come_together_grpc::image>* reactor) override;
      #else
      void GetImages(::grpc::ClientContext* context, ::come_together_grpc::get_images_request* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::image>* reactor) override;
      #endif
      void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, std::function<void(::grpc::Status)>) override;
      void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendChatMessage(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendChatMessage(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_chat_message_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetChatMessages(::grpc::ClientContext* context, ::come_together_grpc::get_chat_messages_request* request, ::grpc::ClientReadReactor< ::come_together_grpc::chat_message>* reactor) override;
      #else
      void GetChatMessages(::grpc::ClientContext* context, ::come_together_grpc::get_chat_messages_request* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::chat_message>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeToEvents(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::ClientReadReactor< ::come_together_grpc::event>* reactor) override;
      #else
      void SubscribeToEvents(::grpc::ClientContext* context, ::come_together_grpc::access_token* request, ::grpc::experimental::ClientReadReactor< ::come_together_grpc::event>* reactor) override;
      #endif
      void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, std::function<void(::grpc::Status)>) override;
      void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendPushToken(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendPushToken(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::come_together_grpc::send_push_token_response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>* AsyncAskTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::ask_token_response>* PrepareAsyncAskTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::ask_token_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>* AsyncVerifyTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::verify_token_response>* PrepareAsyncVerifyTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::verify_token_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>* AsyncCheckRaw(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::check_response>* PrepareAsyncCheckRaw(::grpc::ClientContext* context, const ::come_together_grpc::check_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>* AsyncRegisterUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::register_response>* PrepareAsyncRegisterUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::register_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>* AsyncLoginUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::login_response>* PrepareAsyncLoginUserRaw(::grpc::ClientContext* context, const ::come_together_grpc::login_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>* AsyncAddMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::add_marker_response>* PrepareAsyncAddMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::add_marker_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>* AsyncDeleteMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::delete_marker_reponse>* PrepareAsyncDeleteMarkerRaw(::grpc::ClientContext* context, const ::come_together_grpc::delete_marker_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::come_together_grpc::marker_info>* GetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>* AsyncGetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::marker_info>* PrepareAsyncGetAllMarkersRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>* AsyncGetInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::get_info_response>* PrepareAsyncGetInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>* AsyncUpdateInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::update_info_response>* PrepareAsyncUpdateInfoRaw(::grpc::ClientContext* context, const ::come_together_grpc::update_info_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>* AsyncManageImageRaw(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::manage_image_response>* PrepareAsyncManageImageRaw(::grpc::ClientContext* context, const ::come_together_grpc::manage_image_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::come_together_grpc::image>* GetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::image>* AsyncGetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::image>* PrepareAsyncGetImagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_images_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>* AsyncSendChatMessageRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_chat_message_response>* PrepareAsyncSendChatMessageRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_chat_message_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::come_together_grpc::chat_message>* GetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>* AsyncGetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::chat_message>* PrepareAsyncGetChatMessagesRaw(::grpc::ClientContext* context, const ::come_together_grpc::get_chat_messages_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::come_together_grpc::event>* SubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::event>* AsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::come_together_grpc::event>* PrepareAsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::come_together_grpc::access_token& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>* AsyncSendPushTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::come_together_grpc::send_push_token_response>* PrepareAsyncSendPushTokenRaw(::grpc::ClientContext* context, const ::come_together_grpc::send_push_token_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AskToken_;
    const ::grpc::internal::RpcMethod rpcmethod_VerifyToken_;
    const ::grpc::internal::RpcMethod rpcmethod_Check_;
    const ::grpc::internal::RpcMethod rpcmethod_RegisterUser_;
    const ::grpc::internal::RpcMethod rpcmethod_LoginUser_;
    const ::grpc::internal::RpcMethod rpcmethod_AddMarker_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteMarker_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllMarkers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_ManageImage_;
    const ::grpc::internal::RpcMethod rpcmethod_GetImages_;
    const ::grpc::internal::RpcMethod rpcmethod_SendChatMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_GetChatMessages_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeToEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_SendPushToken_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status AskToken(::grpc::ServerContext* context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response);
    virtual ::grpc::Status VerifyToken(::grpc::ServerContext* context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response);
    // **********************************************************//
    virtual ::grpc::Status Check(::grpc::ServerContext* context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response);
    virtual ::grpc::Status RegisterUser(::grpc::ServerContext* context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response);
    virtual ::grpc::Status LoginUser(::grpc::ServerContext* context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response);
    // **********************************************************//
    virtual ::grpc::Status AddMarker(::grpc::ServerContext* context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response);
    virtual ::grpc::Status DeleteMarker(::grpc::ServerContext* context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response);
    // may be unused (for now)
    virtual ::grpc::Status GetAllMarkers(::grpc::ServerContext* context, const ::come_together_grpc::access_token* request, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* writer);
    // **********************************************************//
    // may be unused (for now)
    virtual ::grpc::Status GetInfo(::grpc::ServerContext* context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response);
    virtual ::grpc::Status UpdateInfo(::grpc::ServerContext* context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response);
    // **********************************************************//
    virtual ::grpc::Status ManageImage(::grpc::ServerContext* context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response);
    virtual ::grpc::Status GetImages(::grpc::ServerContext* context, const ::come_together_grpc::get_images_request* request, ::grpc::ServerWriter< ::come_together_grpc::image>* writer);
    // **********************************************************//
    virtual ::grpc::Status SendChatMessage(::grpc::ServerContext* context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response);
    virtual ::grpc::Status GetChatMessages(::grpc::ServerContext* context, const ::come_together_grpc::get_chat_messages_request* request, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* writer);
    //
    // Events:
    // Add new marker to map or message to chat
    // Edit existing marker, message or user profile
    // Delete existing marker or image
    virtual ::grpc::Status SubscribeToEvents(::grpc::ServerContext* context, const ::come_together_grpc::access_token* request, ::grpc::ServerWriter< ::come_together_grpc::event>* writer);
    virtual ::grpc::Status SendPushToken(::grpc::ServerContext* context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AskToken() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAskToken(::grpc::ServerContext* context, ::come_together_grpc::ask_token_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::ask_token_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_VerifyToken() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyToken(::grpc::ServerContext* context, ::come_together_grpc::verify_token_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::verify_token_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Check() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::come_together_grpc::check_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::check_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegisterUser() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterUser(::grpc::ServerContext* context, ::come_together_grpc::register_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::register_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoginUser() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUser(::grpc::ServerContext* context, ::come_together_grpc::login_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::login_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddMarker() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddMarker(::grpc::ServerContext* context, ::come_together_grpc::add_marker_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::add_marker_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteMarker() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMarker(::grpc::ServerContext* context, ::come_together_grpc::delete_marker_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::delete_marker_reponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllMarkers() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllMarkers(::grpc::ServerContext* context, ::come_together_grpc::access_token* request, ::grpc::ServerAsyncWriter< ::come_together_grpc::marker_info>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetInfo() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInfo(::grpc::ServerContext* context, ::come_together_grpc::get_info_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::get_info_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateInfo() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateInfo(::grpc::ServerContext* context, ::come_together_grpc::update_info_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::update_info_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ManageImage() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManageImage(::grpc::ServerContext* context, ::come_together_grpc::manage_image_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::manage_image_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetImages() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImages(::grpc::ServerContext* context, ::come_together_grpc::get_images_request* request, ::grpc::ServerAsyncWriter< ::come_together_grpc::image>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendChatMessage() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendChatMessage(::grpc::ServerContext* context, ::come_together_grpc::send_chat_message_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::send_chat_message_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetChatMessages() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChatMessages(::grpc::ServerContext* context, ::come_together_grpc::get_chat_messages_request* request, ::grpc::ServerAsyncWriter< ::come_together_grpc::chat_message>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(13, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEvents(::grpc::ServerContext* context, ::come_together_grpc::access_token* request, ::grpc::ServerAsyncWriter< ::come_together_grpc::event>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendPushToken() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPushToken(::grpc::ServerContext* context, ::come_together_grpc::send_push_token_request* request, ::grpc::ServerAsyncResponseWriter< ::come_together_grpc::send_push_token_response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AskToken<WithAsyncMethod_VerifyToken<WithAsyncMethod_Check<WithAsyncMethod_RegisterUser<WithAsyncMethod_LoginUser<WithAsyncMethod_AddMarker<WithAsyncMethod_DeleteMarker<WithAsyncMethod_GetAllMarkers<WithAsyncMethod_GetInfo<WithAsyncMethod_UpdateInfo<WithAsyncMethod_ManageImage<WithAsyncMethod_GetImages<WithAsyncMethod_SendChatMessage<WithAsyncMethod_GetChatMessages<WithAsyncMethod_SubscribeToEvents<WithAsyncMethod_SendPushToken<Service > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AskToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::ask_token_request, ::come_together_grpc::ask_token_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::ask_token_request* request, ::come_together_grpc::ask_token_response* response) { return this->AskToken(context, request, response); }));}
    void SetMessageAllocatorFor_AskToken(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::ask_token_request, ::come_together_grpc::ask_token_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::ask_token_request, ::come_together_grpc::ask_token_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AskToken(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AskToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_VerifyToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::verify_token_request, ::come_together_grpc::verify_token_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::verify_token_request* request, ::come_together_grpc::verify_token_response* response) { return this->VerifyToken(context, request, response); }));}
    void SetMessageAllocatorFor_VerifyToken(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::verify_token_request, ::come_together_grpc::verify_token_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::verify_token_request, ::come_together_grpc::verify_token_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyToken(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::check_request, ::come_together_grpc::check_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::check_request* request, ::come_together_grpc::check_response* response) { return this->Check(context, request, response); }));}
    void SetMessageAllocatorFor_Check(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::check_request, ::come_together_grpc::check_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::check_request, ::come_together_grpc::check_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RegisterUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::register_request, ::come_together_grpc::register_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::register_request* request, ::come_together_grpc::register_response* response) { return this->RegisterUser(context, request, response); }));}
    void SetMessageAllocatorFor_RegisterUser(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::register_request, ::come_together_grpc::register_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::register_request, ::come_together_grpc::register_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterUser(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LoginUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::login_request, ::come_together_grpc::login_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::login_request* request, ::come_together_grpc::login_response* response) { return this->LoginUser(context, request, response); }));}
    void SetMessageAllocatorFor_LoginUser(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::login_request, ::come_together_grpc::login_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::login_request, ::come_together_grpc::login_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LoginUser(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LoginUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddMarker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::add_marker_request, ::come_together_grpc::add_marker_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::add_marker_request* request, ::come_together_grpc::add_marker_response* response) { return this->AddMarker(context, request, response); }));}
    void SetMessageAllocatorFor_AddMarker(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::add_marker_request, ::come_together_grpc::add_marker_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::add_marker_request, ::come_together_grpc::add_marker_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddMarker(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddMarker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteMarker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::delete_marker_request, ::come_together_grpc::delete_marker_reponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::delete_marker_request* request, ::come_together_grpc::delete_marker_reponse* response) { return this->DeleteMarker(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteMarker(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::delete_marker_request, ::come_together_grpc::delete_marker_reponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::delete_marker_request, ::come_together_grpc::delete_marker_reponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMarker(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMarker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAllMarkers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::come_together_grpc::access_token, ::come_together_grpc::marker_info>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::access_token* request) { return this->GetAllMarkers(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::come_together_grpc::marker_info>* GetAllMarkers(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::come_together_grpc::marker_info>* GetAllMarkers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::get_info_request, ::come_together_grpc::get_info_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::get_info_request* request, ::come_together_grpc::get_info_response* response) { return this->GetInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetInfo(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::get_info_request, ::come_together_grpc::get_info_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::get_info_request, ::come_together_grpc::get_info_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::update_info_request, ::come_together_grpc::update_info_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::update_info_request* request, ::come_together_grpc::update_info_response* response) { return this->UpdateInfo(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateInfo(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::update_info_request, ::come_together_grpc::update_info_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::update_info_request, ::come_together_grpc::update_info_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ManageImage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::manage_image_request, ::come_together_grpc::manage_image_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::manage_image_request* request, ::come_together_grpc::manage_image_response* response) { return this->ManageImage(context, request, response); }));}
    void SetMessageAllocatorFor_ManageImage(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::manage_image_request, ::come_together_grpc::manage_image_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::manage_image_request, ::come_together_grpc::manage_image_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ManageImage(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ManageImage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetImages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::come_together_grpc::get_images_request, ::come_together_grpc::image>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::get_images_request* request) { return this->GetImages(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::come_together_grpc::image>* GetImages(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::come_together_grpc::image>* GetImages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendChatMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::send_chat_message_request, ::come_together_grpc::send_chat_message_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::send_chat_message_request* request, ::come_together_grpc::send_chat_message_response* response) { return this->SendChatMessage(context, request, response); }));}
    void SetMessageAllocatorFor_SendChatMessage(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::send_chat_message_request, ::come_together_grpc::send_chat_message_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::send_chat_message_request, ::come_together_grpc::send_chat_message_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendChatMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendChatMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetChatMessages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::come_together_grpc::get_chat_messages_request, ::come_together_grpc::chat_message>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::get_chat_messages_request* request) { return this->GetChatMessages(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::come_together_grpc::chat_message>* GetChatMessages(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::come_together_grpc::chat_message>* GetChatMessages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeToEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::come_together_grpc::access_token, ::come_together_grpc::event>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::access_token* request) { return this->SubscribeToEvents(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::come_together_grpc::event>* SubscribeToEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::come_together_grpc::event>* SubscribeToEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendPushToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::send_push_token_request, ::come_together_grpc::send_push_token_response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::come_together_grpc::send_push_token_request* request, ::come_together_grpc::send_push_token_response* response) { return this->SendPushToken(context, request, response); }));}
    void SetMessageAllocatorFor_SendPushToken(
        ::grpc::experimental::MessageAllocator< ::come_together_grpc::send_push_token_request, ::come_together_grpc::send_push_token_response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::come_together_grpc::send_push_token_request, ::come_together_grpc::send_push_token_response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendPushToken(
      ::grpc::CallbackServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendPushToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_AskToken<ExperimentalWithCallbackMethod_VerifyToken<ExperimentalWithCallbackMethod_Check<ExperimentalWithCallbackMethod_RegisterUser<ExperimentalWithCallbackMethod_LoginUser<ExperimentalWithCallbackMethod_AddMarker<ExperimentalWithCallbackMethod_DeleteMarker<ExperimentalWithCallbackMethod_GetAllMarkers<ExperimentalWithCallbackMethod_GetInfo<ExperimentalWithCallbackMethod_UpdateInfo<ExperimentalWithCallbackMethod_ManageImage<ExperimentalWithCallbackMethod_GetImages<ExperimentalWithCallbackMethod_SendChatMessage<ExperimentalWithCallbackMethod_GetChatMessages<ExperimentalWithCallbackMethod_SubscribeToEvents<ExperimentalWithCallbackMethod_SendPushToken<Service > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_AskToken<ExperimentalWithCallbackMethod_VerifyToken<ExperimentalWithCallbackMethod_Check<ExperimentalWithCallbackMethod_RegisterUser<ExperimentalWithCallbackMethod_LoginUser<ExperimentalWithCallbackMethod_AddMarker<ExperimentalWithCallbackMethod_DeleteMarker<ExperimentalWithCallbackMethod_GetAllMarkers<ExperimentalWithCallbackMethod_GetInfo<ExperimentalWithCallbackMethod_UpdateInfo<ExperimentalWithCallbackMethod_ManageImage<ExperimentalWithCallbackMethod_GetImages<ExperimentalWithCallbackMethod_SendChatMessage<ExperimentalWithCallbackMethod_GetChatMessages<ExperimentalWithCallbackMethod_SubscribeToEvents<ExperimentalWithCallbackMethod_SendPushToken<Service > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AskToken() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_VerifyToken() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Check() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegisterUser() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoginUser() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddMarker() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteMarker() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllMarkers() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetInfo() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateInfo() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ManageImage() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetImages() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendChatMessage() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetChatMessages() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendPushToken() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AskToken() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAskToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_VerifyToken() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVerifyToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Check() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegisterUser() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegisterUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoginUser() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoginUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddMarker() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddMarker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteMarker() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMarker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllMarkers() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllMarkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetInfo() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateInfo() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ManageImage() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestManageImage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetImages() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetImages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendChatMessage() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendChatMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetChatMessages() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetChatMessages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(13, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendPushToken() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendPushToken(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AskToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AskToken(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AskToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AskToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_VerifyToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->VerifyToken(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* VerifyToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* VerifyToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Check() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Check(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Check(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RegisterUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RegisterUser(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RegisterUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RegisterUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LoginUser() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoginUser(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LoginUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LoginUser(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddMarker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddMarker(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddMarker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddMarker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteMarker() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteMarker(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteMarker(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteMarker(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllMarkers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetAllMarkers(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetAllMarkers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetAllMarkers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ManageImage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ManageImage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ManageImage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ManageImage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetImages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetImages(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetImages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetImages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendChatMessage() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendChatMessage(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendChatMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendChatMessage(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetChatMessages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->GetChatMessages(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetChatMessages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* GetChatMessages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeToEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeToEvents(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendPushToken() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendPushToken(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendPushToken(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendPushToken(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AskToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AskToken() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::ask_token_request, ::come_together_grpc::ask_token_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::ask_token_request, ::come_together_grpc::ask_token_response>* streamer) {
                       return this->StreamedAskToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AskToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AskToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::ask_token_request* /*request*/, ::come_together_grpc::ask_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAskToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::ask_token_request,::come_together_grpc::ask_token_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_VerifyToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_VerifyToken() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::verify_token_request, ::come_together_grpc::verify_token_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::verify_token_request, ::come_together_grpc::verify_token_response>* streamer) {
                       return this->StreamedVerifyToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_VerifyToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status VerifyToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::verify_token_request* /*request*/, ::come_together_grpc::verify_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVerifyToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::verify_token_request,::come_together_grpc::verify_token_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Check() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::check_request, ::come_together_grpc::check_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::check_request, ::come_together_grpc::check_response>* streamer) {
                       return this->StreamedCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Check(::grpc::ServerContext* /*context*/, const ::come_together_grpc::check_request* /*request*/, ::come_together_grpc::check_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::check_request,::come_together_grpc::check_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RegisterUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RegisterUser() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::register_request, ::come_together_grpc::register_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::register_request, ::come_together_grpc::register_response>* streamer) {
                       return this->StreamedRegisterUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RegisterUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RegisterUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::register_request* /*request*/, ::come_together_grpc::register_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegisterUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::register_request,::come_together_grpc::register_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoginUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoginUser() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::login_request, ::come_together_grpc::login_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::login_request, ::come_together_grpc::login_response>* streamer) {
                       return this->StreamedLoginUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoginUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoginUser(::grpc::ServerContext* /*context*/, const ::come_together_grpc::login_request* /*request*/, ::come_together_grpc::login_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoginUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::login_request,::come_together_grpc::login_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddMarker() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::add_marker_request, ::come_together_grpc::add_marker_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::add_marker_request, ::come_together_grpc::add_marker_response>* streamer) {
                       return this->StreamedAddMarker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::add_marker_request* /*request*/, ::come_together_grpc::add_marker_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddMarker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::add_marker_request,::come_together_grpc::add_marker_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteMarker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteMarker() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::delete_marker_request, ::come_together_grpc::delete_marker_reponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::delete_marker_request, ::come_together_grpc::delete_marker_reponse>* streamer) {
                       return this->StreamedDeleteMarker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteMarker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteMarker(::grpc::ServerContext* /*context*/, const ::come_together_grpc::delete_marker_request* /*request*/, ::come_together_grpc::delete_marker_reponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteMarker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::delete_marker_request,::come_together_grpc::delete_marker_reponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetInfo() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::get_info_request, ::come_together_grpc::get_info_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::get_info_request, ::come_together_grpc::get_info_response>* streamer) {
                       return this->StreamedGetInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_info_request* /*request*/, ::come_together_grpc::get_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::get_info_request,::come_together_grpc::get_info_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateInfo() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::update_info_request, ::come_together_grpc::update_info_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::update_info_request, ::come_together_grpc::update_info_response>* streamer) {
                       return this->StreamedUpdateInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateInfo(::grpc::ServerContext* /*context*/, const ::come_together_grpc::update_info_request* /*request*/, ::come_together_grpc::update_info_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::update_info_request,::come_together_grpc::update_info_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ManageImage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ManageImage() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::manage_image_request, ::come_together_grpc::manage_image_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::manage_image_request, ::come_together_grpc::manage_image_response>* streamer) {
                       return this->StreamedManageImage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ManageImage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ManageImage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::manage_image_request* /*request*/, ::come_together_grpc::manage_image_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedManageImage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::manage_image_request,::come_together_grpc::manage_image_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendChatMessage() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::send_chat_message_request, ::come_together_grpc::send_chat_message_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::send_chat_message_request, ::come_together_grpc::send_chat_message_response>* streamer) {
                       return this->StreamedSendChatMessage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendChatMessage(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_chat_message_request* /*request*/, ::come_together_grpc::send_chat_message_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendChatMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::send_chat_message_request,::come_together_grpc::send_chat_message_response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendPushToken : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendPushToken() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::come_together_grpc::send_push_token_request, ::come_together_grpc::send_push_token_response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::come_together_grpc::send_push_token_request, ::come_together_grpc::send_push_token_response>* streamer) {
                       return this->StreamedSendPushToken(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendPushToken() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendPushToken(::grpc::ServerContext* /*context*/, const ::come_together_grpc::send_push_token_request* /*request*/, ::come_together_grpc::send_push_token_response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendPushToken(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::come_together_grpc::send_push_token_request,::come_together_grpc::send_push_token_response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AskToken<WithStreamedUnaryMethod_VerifyToken<WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_RegisterUser<WithStreamedUnaryMethod_LoginUser<WithStreamedUnaryMethod_AddMarker<WithStreamedUnaryMethod_DeleteMarker<WithStreamedUnaryMethod_GetInfo<WithStreamedUnaryMethod_UpdateInfo<WithStreamedUnaryMethod_ManageImage<WithStreamedUnaryMethod_SendChatMessage<WithStreamedUnaryMethod_SendPushToken<Service > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetAllMarkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetAllMarkers() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::come_together_grpc::access_token, ::come_together_grpc::marker_info>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::come_together_grpc::access_token, ::come_together_grpc::marker_info>* streamer) {
                       return this->StreamedGetAllMarkers(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetAllMarkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllMarkers(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::marker_info>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetAllMarkers(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::come_together_grpc::access_token,::come_together_grpc::marker_info>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetImages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetImages() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::come_together_grpc::get_images_request, ::come_together_grpc::image>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::come_together_grpc::get_images_request, ::come_together_grpc::image>* streamer) {
                       return this->StreamedGetImages(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetImages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetImages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_images_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetImages(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::come_together_grpc::get_images_request,::come_together_grpc::image>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_GetChatMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetChatMessages() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::come_together_grpc::get_chat_messages_request, ::come_together_grpc::chat_message>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::come_together_grpc::get_chat_messages_request, ::come_together_grpc::chat_message>* streamer) {
                       return this->StreamedGetChatMessages(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetChatMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetChatMessages(::grpc::ServerContext* /*context*/, const ::come_together_grpc::get_chat_messages_request* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::chat_message>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetChatMessages(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::come_together_grpc::get_chat_messages_request,::come_together_grpc::chat_message>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::come_together_grpc::access_token, ::come_together_grpc::event>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::come_together_grpc::access_token, ::come_together_grpc::event>* streamer) {
                       return this->StreamedSubscribeToEvents(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::come_together_grpc::access_token* /*request*/, ::grpc::ServerWriter< ::come_together_grpc::event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeToEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::come_together_grpc::access_token,::come_together_grpc::event>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetAllMarkers<WithSplitStreamingMethod_GetImages<WithSplitStreamingMethod_GetChatMessages<WithSplitStreamingMethod_SubscribeToEvents<Service > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_AskToken<WithStreamedUnaryMethod_VerifyToken<WithStreamedUnaryMethod_Check<WithStreamedUnaryMethod_RegisterUser<WithStreamedUnaryMethod_LoginUser<WithStreamedUnaryMethod_AddMarker<WithStreamedUnaryMethod_DeleteMarker<WithSplitStreamingMethod_GetAllMarkers<WithStreamedUnaryMethod_GetInfo<WithStreamedUnaryMethod_UpdateInfo<WithStreamedUnaryMethod_ManageImage<WithSplitStreamingMethod_GetImages<WithStreamedUnaryMethod_SendChatMessage<WithSplitStreamingMethod_GetChatMessages<WithSplitStreamingMethod_SubscribeToEvents<WithStreamedUnaryMethod_SendPushToken<Service > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace come_together_grpc


#endif  // GRPC_come_5ftogether_2eproto__INCLUDED
